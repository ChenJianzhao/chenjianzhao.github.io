## 概述（为何没有谈及永久代）

### 为何要了解GC和内存分配

当需要排查各种内存溢出，内存泄漏问题时，当垃圾收称为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。



## 对象已死吗

### 引用计数器法

**描述：**给对象中添加一个引用计数器每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能在被使用的。

**缺陷：**很难解决对象间相互循环引用的问题。



### 可达性分析算法

在主流的商用语言的主流实现中，都是称通过可达性分析（Reachablity Analysis）来判断对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是从 GC Roots 到这个对象不可达）时，则证明对象是不可用的。



在 Java 语言中，可作为 GC Roots 的对象包括下面几种

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中 JNI （即一般说的 Native 方法）引用的对象。



### 再谈引用

在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。

- **强引用** ：在程序代码中普遍存在，垃圾收集器永远不会回收被引用的对象。
- **软引用** ：是用来描述一些还有用但并非必须的对象。在系统将要**发生内存溢出异常之前**，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
- **弱引用**：也是用来描述非必须对象的，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
- **虚引用**：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。唯一的目的就是能在这个对象被收集器回收时收到一个系统通知。



### 生存还是死亡

finalize 相关



### 回收方法区

Java虚拟机规范中确实说过可以**不要求虚拟机在方法区实现垃圾收集**，而且在方法区中进行垃圾收集的**“性价比”一般比较低**：在堆中，尤其在新生代中，常规的应用一次垃圾收集一般可以回收**70% ~ 95%的空间**，而永久代的垃圾收集效率远低于此。

永久代的垃圾收集主要回收两部分：**废弃常量** 和 **无用的类**。 

- 回收废弃常量与回收 Java 堆中的对象非常类似。
- 要判定一个类是否是“无用的类”的条件相对苛刻许多。类需要同时满足下面3个条件才能算“无用的类”
  1. 该类的所有实例都已经被回收。
  2. 加载该类的 ClassLoader 已经被回收。
  3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

在大量使用反射、动态代理、GGLib 等 ByteCode 框架、动态生成 Jsp 以及 OSGI 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。



## 垃圾收集算法

### 标记-清除算法

最基础的收集算法是“标记-清除”（Mark-Sweep）算法，算法分为两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象。

**不足：** 

1. **效率问题**：标记和清除的效率都不高

2. **空间问题**：标记清除之后会产生大量不连续的内存碎片，导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另外一次垃圾收集。

   ​



### 复制算法（Copying）

现在的商业虚拟机都采用这种收集算法来回收新生代。

HotSopt 将内存分为一块比较大的 Eden 空间和两块比较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和 刚才用过的 Survivor 空间。 

HotSopt 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，也就是新生代中可用内存空间为整个新生代容量的 90%（80%+10%），只有10%的内存会被“浪费”。

当 Survivor 空间不够用时，需要依赖其他内存（老年代）进行**分类担保**（Handle Promotion）。如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象向直接通过分配担保机制进入老年代。



### 标记-整理算法（Mark-Compact）

复制收集算法在对象存活率较高时就要进行较多的复制操作，效率会变低。更关键的是，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，所以老年代一般不能直接选用这种算法。

“标记-整理”算法的标记过程仍然与“标记-清除”算法一样，而后续是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。



### 分带收集算法（Generation Collection）

当前商业虚拟机的垃圾收集都采用“分代收集”算法。根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

在新生代中，每次垃圾收集时都发现大批对象死去，只有少量存活，那就选用复制算法。

老年代中因为对象存活率高、没有额外的空间对他进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法。



## HotSpot的算法实现

### 枚举根节点

**存在的问题**

可作为 GC Roots 的节点主要是在全局的引用（例如常量或者类静态属性）与执行上下文（例如栈帧中的本地变量表）中。

现在很多应用仅仅方法区就有数百兆，如果逐个检查这里面的引用，会消耗很多时间。

可达性分析对执行时间的敏感还体现在 GC 停顿上，因为分析必须在一个能确保一致性的快照中进行。