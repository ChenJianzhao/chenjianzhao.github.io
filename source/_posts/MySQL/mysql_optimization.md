---
categories: MySQL
date: 2018-01-26 15:00
title: MySQL 优化建议
---

## 查询缓存

**为查询缓存优化你的查询**

大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。

但是在某些情况下，某些查询语句会让MySQL不使用缓存。请看下面的示例：

```sql
// 查询缓存不开启
SELECT username FROM user WHERE signup_date >= CURDATE();
 
// 开启查询缓存
SELECT username FROM user WHERE signup_date >= 2018-01-31;
```

上面两条SQL语句的差别就是 CURDATE() ，MySQL的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而开启缓存。



## 限制返回记录 LIMIT

**当只要一行数据时使用 LIMIT 1**

当你查询表的有些时候，你已经知道结果只会有一条结果，在这种情况下，加上 `LIMIT 1` 可以增加性能。这样一样，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。

```sql
// 没有效率的：
SELECT * FROM user WHERE country = 'China';

// 有效率的：
SELECT 1 FROM user WHERE country = 'China' LIMIT 1;
```



## 统计行数 COUNT

**统计行数使用 select count(1) 和 select count(*) 代替  select count('table_filed')**

`Count(*)` 或者 `Count(1)` 或者 `Count([列])` 或许是最常用的聚合函数。很多人其实对这三者之间是区分不清的。本文会阐述这三者的作用，关系以及背后的原理。

往常会经常看到一些所谓的优化建议不使用 Count(* ) 而是使用Count(1)，从而可以提升性能，给出的理由是Count( *)会带来全表扫描。而实际上如何写Count并没有区别。

Count(1) 和 Count(*) 实际上的意思是，评估Count（）中的表达式是否为NULL，如果为NULL则不计数，而非NULL则会计数。

### **COUNT(NULL)**

在Count中指定NULL（优化器不允许显式指定NULL，因此需要赋值给变量才能指定）。

```sql
mysql> SET @abc = NULL;
mysql> SELECT count(@abc) FROM t_user;

+-------------+
| count(@abc) |
+-------------+
|           0 |
+-------------+
1 row in set (0.00 sec)
```



### **Count(*) 或者Count(1)** 

```sql
mysql> SELECT COUNT(1) FROM t_user;
+----------+
| COUNT(1) |
+----------+
|        2 |
+----------+
1 row in set (0.00 sec)

mysql> SELECT COUNT(*) FROM t_user;
+----------+
| COUNT(*) |
+----------+
|        2 |
+----------+
1 row in set (0.00 sec)
```

 因此当你指定Count(*) 或者Count(1) 或者无论 Count(‘anything’) 时结果都会一样，因为这些值都不为NULL;



### **Count(列)**

```sql
mysql> SELECT COUNT(FUsername) FROM t_user;
+------------------+
| COUNT(FUsername) |
+------------------+
|                2 |
+------------------+
1 row in set (0.00 sec)

mysql> SELECT COUNT(FTruename) FROM t_user;
+------------------+
| COUNT(FTruename) |
+------------------+
|                0 |
+------------------+
1 row in set (0.00 sec)
```

 对于Count（列）来说，同样适用于上面规则，评估列中每一行的值是否为NULL，如果为NULL则不计数，不为NULL则计数。因此Count（列）会计算列或这列的组合不为空的计数。

>  其中, FUsername 全部行不为空，FTruename 全部行为空。



### Count(*) 具体如何执行

前面提到 `Count( )` 有不为NULL的值时，在SQL Server中只需要找出具体表中不为NULL的行数即可，也就是所有行（如果一行值全为NULL则该行相当于不存在）。那么最简单的执行办法是找一列NOT NULL的列，如果该列有索引，则使用该索引，当然，为了性能，SQL Server会选择最窄的索引以减少IO。

```sql
mysql> explain select count(1) from t_user;
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | t_user | index | NULL          | PRIMARY | 4       | NULL |    2 | Using index |
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
1 row in set (0.00 sec)
```

```sql
mysql> explain select count(*) from t_user;
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | t_user | index | NULL          | PRIMARY | 4       | NULL |    2 | Using index |
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
1 row in set (0.00 sec)
```

```sql
mysql> explain select count(FUsername) from t_user;
+----+-------------+--------+------+---------------+------+---------+------+------+-------+
| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+--------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | t_user | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |
+----+-------------+--------+------+---------------+------+---------+------+------+-------+
1 row in set (0.00 sec)
```

可以看出 count(*) 和 count(1) 都自动走了索引，而 count(列) 因为 FUsername 列上没有建立索引，索引走了全表搜索。



### 补充：select 1  & select *

```sql
select 1 from table limit 1;
select xxx(表集合中的任意一行） from table limit 1;
select * from table limit 1
```

- 从作用上来说是没有差别的，都是查看是否有记录，一般是作条件查询用的。


- select 1 from 中的 1 是增加的临时列，是一常量（可以为任意数值）,查到的所有行的值都是它，


- 从效率上来说，1>xxx>*，因为不用查字典表。




## 避免 SELECT  *

从数据库里读出越多的数据，那么查询就会变得越慢。并且如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。

所以，你应该养成一个需要什么就取什么的好的习惯。

```sql
// 不推荐
SELECT * FROM user WHERE user_id = 1;
 
// 推荐
SELECT username FROM user WHERE user_id = 1;
```



## 为每张表设置 ID 主键

**永远为每张表设置一个ID**

我们应该为数据库里的每张表都设置一个ID做为其主键，而且**最好的是一个INT型的（推荐使用UNSIGNED**），并设置上自动增加的 `AUTO_INCREMENT` 标志。

就算是你 users 表有一个主键叫 “email”的字段，你也别让它成为主键。**使用 VARCHAR 类型来当主键会使用得性能下降**。另外，在你的程序中，你应该使用表的ID来构造你的数据结构。

而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区……

 

## 使用 ENUM 而不是 VARCHAR

`ENUM` 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。

如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。

MySQL也有一个“建议”（见第十条）告诉你怎么去重新组织你的表结构。当你有一个 VARCHAR 字段时，这个建议会告诉你把其改成 ENUM 类型。使用 PROCEDURE ANALYSE() 你可以得到相关的建议。



## 尽可能的使用 NOT NULL

除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。

首先，问问你自己“Empty”和“NULL”有多大的区别（如果是INT，那就是0和NULL）？如果你觉得它们之间没有什么区别，那么你就不要使用NULL。（你知道吗？在 Oracle 里，NULL 和 Empty 的字符串是一样的！)

不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。



## Prepared Statements

`Prepared Statements` 很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是**性能问题还是安全问题**。

Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击。

**在性能方面，当一个相同的查询被使用多次的时候**，这会为你带来可观的性能优势。你可以给这些 Prepared Statements 定义一些参数，**而MySQL只会解析一次**。

虽然最新版本的MySQL在传输Prepared Statements是使用二进制形势，所以这会使得网络传输非常有效率。

当然，也有一些情况下，我们需要避免使用Prepared Statements，因为其不支持查询缓存。但据说版本5.1后支持了。



## 固定长度的表会更快

如果表中的所有字段都是“固定长度”的，整个表会被认为是 [“static” 或 “fixed-length”](http://dev.mysql.com/doc/refman/5.1/en/static-format.html)。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。

固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。

并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。

使用“垂直分割”技术（见下一条），你可以分割你的表成为两个一个是定长的，一个则是不定长的。



## 垂直分割

“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。

**示例一**：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你**并不需要经常读取或是改写这个字段**。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。

**示例二**： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，**每次更新时会导致该表的查询缓存被清空**。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。

另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。



##  拆分大的 DELETE 或 INSERT 语句

如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。**因为这两个操作是会锁表的**，表一锁住了，别的操作都进不来了。

Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。

如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上掛了。

所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。



## 越小的列会越快

对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。

参看 MySQL 的文档 [Storage Requirements](http://dev.mysql.com/doc/refman/5.0/en/storage-requirements.html) 查看所有的数据类型。

如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。

当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看[Slashdot的例子](http://news.slashdot.org/article.pl?sid=06/11/09/1534204)（2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。



## 选择正确的存储引擎

在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。酷壳以前文章《[MySQL: InnoDB 还是 MyISAM?](https://coolshell.cn/articles/652.html)》讨论和这个事情。

**MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。**甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。

InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。



