---
categories:
  - 'Java Core'
  - 'Java 进阶'
date: 2017-01-02 14:15
status: public
title: Java内存区域与内存溢出异常
---

## 运行时数据区域
``程序计数器``（Program Counter Register）：当前线程所执行的字节码的行号指示器。
　　**线程私有内存，较小的内存空间。**
　　此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。



``Java虚拟机栈``（Java Virtual Machine Stacks）：描述Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。通常所说的“栈”指的就是虚拟机栈，或者说是虚拟机栈中的局部变量表部分。
　　**线程私有内存，声明周期与线程相同。**
　　**局部变量表**存放了编译期可知的各种基本数据类型、对象引用类型。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。**局部变量表所需的内存空间在编译期间完成分配**，当进入一个方法时，这个方法所需要在帧中分配多大的局部变量空间是**完全确定**的，在方法的运行期间不会改变局部变量表的大小。



``本地方法栈``（Native Method Stack）与虚拟机栈所发挥的作用非常相似。Sun HotSpot 虚拟机直接就把本地方法栈和虚拟机栈合二为一（因此虚拟机设置本地方法栈大小的参数，-Xoss，在Hot Spot虚拟机实现中是无效的）。



``Java堆``（Java Heap）：存放对象实例，几乎所有的对象实例都在这里分配内存。但随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，因此所有对象都分配在堆上不是那么绝对。
**Java虚拟机所管理的内存中最大的一块，线程共享，在虚拟机启动时创建。**
Java堆是垃圾收集器管理的主要区域，因此也称作“GC堆”(Garbage Collected Heap)



``方法区``（Menthod Area）：**线程共享**，用于存储已被虚拟机加载的类信息、常量 、静态变量、即时编译器编译后的代码等数据。
HotSpot虚拟机把GC分代收集拓展至方法区，使用永久代来实现方法区。



``运行时常量池``（Runtime Constant Pool）是方法区的一部分。Class文件中有一项信息是常量池（Constant Pool Table），用于存放在编译期生成的各种字面量和符号引用，**这部分内容将在类加载后进入方法区的运行时常量池中存放。**



``直接内存``（Direct Memory）并不是虚拟机运行时数据区的一部分，属于**堆外内存**。
NIO类，引入了一种基于通道与缓冲区的I/O方式，他可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的 ``DirectByteBuffer`` 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

显然，本机直接内存的分配不会受到Java堆大小的限制，但是还是会受到本地总内存大小以及处理器寻址空间的限制。



## 普通Java对象的创建过程

（不包括数组和Class对象等）

``类加载检查 --> 内存分配 --> 初始化为零值 --> 设置对象头 --> 执行<init>方法``

### 类加载检查

虚拟机遇到一条new指令时，首先将去**检查这个指令的参数是否能在常量池中定位到一个类的符号引用**，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的**类加载过程。**



### 内存分配

在类加载检查通过之后，虚拟机将为新生对象**分配内存**。

#### 内存分配的方式有两种

1. ``“指针碰撞”``：假设Java堆中内存是绝对规整的，用过的内存放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那分配内存就仅仅是把那个指针向空闲空间那边**挪动一段与对象大小相等的距离**。
2. ``“空闲列表”``：假设Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，虚拟机就必须**维护一个列表**，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

**选择哪种分配方式由Java堆是否规整决定，而是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。**



#### 内存分配的线程安全

内存分配时，修改一个指针所指向的位置，在并发情况下也并不是线程安全的。解决方案有两种：

1. **对分配内存空间的动作进行同步处理**，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。
2. 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为**本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）**。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要**同步锁定**。虚拟机是否使用TLAB，可以通过 -XX:+/-UseTLAB 参数来设定。



### 初始化为零值

内存分配完成后，虚拟机需要将分配到的内存空间都**初始化为零值**（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用。



### 设置对象头

接下来，虚拟机要对对象进行必要的的设置，**存放在对象的对象头**（Object Header）中。



### 执行<init>方法

完成以上工作后，从虚拟机的角度讲，一个新的对象已经产生了，但从Java程序的视角来看，执行new指令之后会接着**执行<init>方法**，把对象按照程序员的意愿进行初始化。



## 对象的内存布局

　　HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：**对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）**。

1. **对象头**：包括两部分。
    - 对象本身的运行时数据（哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等）
    - 类型指针，即对象指向它的类元数据的指针。
2. **实例数据**：对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。
3. **对齐填充**：并不是 必然存在的，也没有特别的含义，它仅仅起着占位符的作用。




## 对象的访问定位

　　Java程序通过栈上的reference数据来操作堆上的具体对象。对象的访问方式取决于虚拟机的实现。
主流的访问方式：**句柄和直接指针**
1. **句柄访问**：Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
   ``reference`` --> ``|到对象实例数据的指针｜到对象类型数据的指针`` -->  ``对象类型数据``
   　　　　　　　　　　　　　　　｜
   　　　　　　　　　　　　``对象实例数据``

2. **直接指针访问**：
   ``reference``  -->  ``对象实例数据【到对象类型数据的指针】`` -->  ``对象类型数据``

**各自的优势：**
句柄访问：reference中存储的是稳定的句柄地址，在对象移动（垃圾收集）时只会改变句柄中的实例数据指针，而reference本身不需要修改。
直接指针：访问速度快，它节省了一次指针定位的时间开销。sun HotSpot 使用第二种方式进行对象的访问。



## 内存溢出

