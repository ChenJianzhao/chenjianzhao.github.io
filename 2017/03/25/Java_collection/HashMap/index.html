<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="整理转载自java集合类深入分析之HashSet, HashMap篇
一、HashMap概述：
HashMap是基于哈希表的Map接口的非同步实现。允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。

最常见的两种操作方法是get, put方法。get方法用于根据Key来取得所需要的Value值，而put方法用于根据特定的Key来放置对应的Value。除了这两个方">
<meta property="og:type" content="article">
<meta property="og:title" content="Java集合类深入分析之HashMap(jdk1.6中的实现)">
<meta property="og:url" content="http://yoursite.com/2017/03/25/Java_collection/HashMap/index.html">
<meta property="og:site_name" content="Pandora">
<meta property="og:description" content="整理转载自java集合类深入分析之HashSet, HashMap篇
一、HashMap概述：
HashMap是基于哈希表的Map接口的非同步实现。允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。

最常见的两种操作方法是get, put方法。get方法用于根据Key来取得所需要的Value值，而put方法用于根据特定的Key来放置对应的Value。除了这两个方">
<meta property="og:image" content="http://yoursite.com/2017/03/25/Java_collection/HashMap/hashmap.jpg">
<meta property="og:updated_time" content="2017-11-06T00:34:00.191Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java集合类深入分析之HashMap(jdk1.6中的实现)">
<meta name="twitter:description" content="整理转载自java集合类深入分析之HashSet, HashMap篇
一、HashMap概述：
HashMap是基于哈希表的Map接口的非同步实现。允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。

最常见的两种操作方法是get, put方法。get方法用于根据Key来取得所需要的Value值，而put方法用于根据特定的Key来放置对应的Value。除了这两个方">
<meta name="twitter:image" content="http://yoursite.com/2017/03/25/Java_collection/HashMap/hashmap.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/03/25/Java_collection/HashMap/"/>





  <title> Java集合类深入分析之HashMap(jdk1.6中的实现) | Pandora </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Pandora</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/25/Java_collection/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jianzhao Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pandora">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java集合类深入分析之HashMap(jdk1.6中的实现)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-25T22:46:00+08:00">
                2017-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Core/" itemprop="url" rel="index">
                    <span itemprop="name">Java Core</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Core/Java-集合/" itemprop="url" rel="index">
                    <span itemprop="name">Java 集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/25/Java_collection/HashMap/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/25/Java_collection/HashMap/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>整理转载自<br><a href="http://sauzny.iteye.com/blog/2020275" target="_blank" rel="external">java集合类深入分析之HashSet, HashMap篇</a></p>
<h2 id="一、HashMap概述："><a href="#一、HashMap概述：" class="headerlink" title="一、HashMap概述："></a>一、HashMap概述：</h2><ol>
<li><p>HashMap是基于哈希表的Map接口的非同步实现。允许使用<strong>null值和null键</strong>。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
</li>
<li><p>最常见的两种操作方法是<code>get</code>, <code>put</code>方法。get方法用于根据Key来取得所需要的Value值，而put方法用于根据特定的Key来放置对应的Value。除了这两个方法以外还有判断Key,Value是否存在的containsKey, containsValue方法。</p>
</li>
<li><p>Map类型的数据结构有一个比较好的地方就是在存取元素的时候都能够有比较高的效率。 因为每次存取元素的时候都是通过计算Key的hash值再通过一定的映射规则来实现，在理想的情况下可以达到一个常量值。</p>
<a id="more"></a>
<p><strong>下面这部分是Map里面主要方法的列表：</strong></p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">方法详细定义</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">containsKey</td>
<td style="text-align:left">boolean containsKey(Object key);</td>
<td style="text-align:left">判断名是否存在</td>
</tr>
<tr>
<td style="text-align:left">containsValue</td>
<td style="text-align:left">boolean containsValue(Object value);</td>
<td style="text-align:left">判断值是否存在</td>
</tr>
<tr>
<td style="text-align:left">get</td>
<td style="text-align:left">V get(Object key);</td>
<td style="text-align:left">读取元素</td>
</tr>
<tr>
<td style="text-align:left">put</td>
<td style="text-align:left">V put(K key, V value);</td>
<td style="text-align:left">设置元素</td>
</tr>
<tr>
<td style="text-align:left">keySet</td>
<td style="text-align:left">Set<k> keySet();</k></td>
<td style="text-align:left">所有key值合集</td>
</tr>
<tr>
<td style="text-align:left">values</td>
<td style="text-align:left">Collection<v> values();</v></td>
<td style="text-align:left">所有value的集合</td>
</tr>
<tr>
<td style="text-align:left">entrySet</td>
<td style="text-align:left">Set<map.entry<k, v="">&gt; entrySet();</map.entry<k,></td>
<td style="text-align:left">键值对集合</td>
</tr>
</tbody>
</table>
<h2 id="二、HashMap的数据结构："><a href="#二、HashMap的数据结构：" class="headerlink" title="二、HashMap的数据结构："></a>二、HashMap的数据结构：</h2><p><strong>HashMap 实际上是一个链表数组。</strong><br><img src="/2017/03/25/Java_collection/HashMap/hashmap.jpg" alt="HashMap"></p>
<p><strong>内部结构</strong></p>
<ul>
<li>我们根据这种<strong>链表数组</strong>的类型，可以推断它内部肯定是有一个链表的结构。在HashMap内部，有一个<code>transient</code> （不参与序列化，序列化后根据平台Hash算法重新生成映射）Entry[] table。</li>
<li>这样的结构数组，它保存所有Entry的一个列表。而Entry的定义是一个典型的链表结构，不过由于既要有Key也要有Value，所以包含了Key, Value两个值。他们的定义如下：（为何使用 transient 下文补充）</li>
</ul>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">    <span class="keyword">final</span> K key;  </div><div class="line">    V value;  </div><div class="line">    Entry&lt;K,V&gt; next;  <span class="comment">// 下一个节点</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  </div><div class="line"></div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Creates new entry. </div><div class="line">     */  </div><div class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;  </div><div class="line">        value = v;  </div><div class="line">        next = n;  </div><div class="line">        key = k;  </div><div class="line">        hash = h;  </div><div class="line">    &#125;  </div><div class="line"><span class="comment">//...  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里省略了其他部分，主要把他们这个链表结构部分突出来。这部分就相当于链表里一个个的Node节点。ok，这样我们至少已经清楚了它里面是怎么组成的了。</p>
<h2 id="三、数组增长调整（Rehashing）"><a href="#三、数组增长调整（Rehashing）" class="headerlink" title="三、数组增长调整（Rehashing）"></a>三、数组增长调整（Rehashing）</h2><p>现在再来看一个地方，我们实际中设计HashMap的时候，这里面<strong>数组的长度</strong>该多少合适呢？是否需要进行动态调整呢？如果是固定死的话，如果我们需要放置的元素少了，岂不是浪费空间？如果我们要放的元素太多了，这样也会导致更大程度的hash碰撞，会带来性能方面的损失。</p>
<ol>
<li>在HashMap里面保存元素的table是可以<strong>动态增长</strong>的，它有一个<strong>默认的长度16</strong>，还有一个<strong>最大长度 2^30</strong>。</li>
<li>在HashMap里面什么时候进行动态增长呢，它有一个<strong>负载因数，默认为0.75</strong>，即元素个数达到数组长度的 75% 时<strong>自动翻倍</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The default initial capacity - MUST be a power of two.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The maximum capacity, used if a higher value is implicitly specified</div><div class="line"> * by either of the constructors with arguments.</div><div class="line"> * MUST be a power of two &lt;= 1&lt;&lt;30.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The load factor used when none specified in constructor.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div></pre></td></tr></table></figure>
<p>在HashMap的构造函数中，可以指定<strong>初始数组的长度</strong>。通过这个初始长度值，构造一个<strong>长度为2的若干次方</strong>的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/**</span></div><div class="line">  	 * Constructor</div><div class="line">  	 * <span class="doctag">@Param</span> initialCapacity 初始化大小(会被替换为大于这个数的最小2的若干次方)</div><div class="line">  	 * <span class="doctag">@Param</span> loadFactor 负载因数</div><div class="line">  	 */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                              initialCapacity);</div><div class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">           initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                              loadFactor);</div><div class="line"></div><div class="line">       <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></div><div class="line">       <span class="keyword">int</span> capacity = <span class="number">1</span>;</div><div class="line">       <span class="keyword">while</span> (capacity &lt; initialCapacity)</div><div class="line">           capacity &lt;&lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">       threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</div><div class="line">       table = <span class="keyword">new</span> Entry[capacity];</div><div class="line">       init();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在我们需要调整数组长度的时候，它的过程和前面讨论过的List, Queue有些类似，但是又有不同的地方。相同的地方在于，它每次也是<strong>将原来的数组长度翻倍</strong>，同时将元素拷贝过去。<strong>但是由于HashMap本身的独特性质，它需要重新做一次映射。</strong>实现这个过程的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;  </div><div class="line">    Entry[] oldTable = table;  </div><div class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;  </div><div class="line">  </div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 当达到最大长度，将 threshold 设为 Integer.MAX_VALUE 并返回，不再增长</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  </div><div class="line">        threshold = Integer.MAX_VALUE;  </div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  </div><div class="line">    transfer(newTable);  </div><div class="line">    table = newTable;  </div><div class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">/** </span></div><div class="line"> * Transfers all entries from current table to newTable. </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;  </div><div class="line">    Entry[] src = table;  </div><div class="line">    <span class="keyword">int</span> newCapacity = newTable.length;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历原来的数组table  </span></div><div class="line">        Entry&lt;K,V&gt; e = src[j];  </div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;  </div><div class="line">            src[j] = <span class="keyword">null</span>;  <span class="comment">// 清除原来的引用，剩下引用 e</span></div><div class="line">            <span class="comment">//对该链表元素里面所有链接的&lt;key, value&gt;对做重新的映射  </span></div><div class="line">          	<span class="keyword">do</span> &#123; </div><div class="line">                <span class="comment">// 记录元素e的 next 引用</span></div><div class="line">                Entry&lt;K,V&gt; next = e.next;  </div><div class="line">              	<span class="comment">// 计算新的下标</span></div><div class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </div><div class="line">                <span class="comment">/* </span></div><div class="line">                 * 这个过程是一个链表头插入的过程，newTabel[i]为原链表头</div><div class="line">                 */</div><div class="line">                e.next = newTable[i];   <span class="comment">// e的next指向表头元素</span></div><div class="line">                newTable[i] = e;  		<span class="comment">// e放入表头</span></div><div class="line">                e = next;  				<span class="comment">// e移动到链表的下一个元素</span></div><div class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>上面的操作实际上就是将旧的数组的元素挪到新的数组中来。因为新数组的长度不一样了，再映射的时候要<strong>对链表里面所有的元素根据新的长度进行重新映射来对应到不同的位置</strong>。</li>
<li>那么，我们可以看出来，元素存放的位置是和数组长度相关的。而这其中具体映射的过程和怎么放置元素的呢？我们在这里就可以找到一个入口点了。就是 <strong>indexFor</strong> 方法。</li>
</ul>
<h2 id="四、详细映射过程"><a href="#四、详细映射过程" class="headerlink" title="四、详细映射过程"></a>四、详细映射过程</h2><p>我们要把一个 &lt; K, V &gt;Entry 放到table中间的某个位置，首先是通过计算key的hashCode值，我们都知道。在java里每个对象都有一个hashCode的方法，返回它对应的hash值。HashMap这边通过这个hash值再进行一次hash()方法的计算，得到一个int的结果。再通过indexFor将它映射到数组的某个索引。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;  </div><div class="line">    <span class="comment">// This function ensures that hashCodes that differ only by  </span></div><div class="line">    <span class="comment">// constant multiples at each bit position have a bounded  </span></div><div class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).  </span></div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);  </div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>hash方法就是对传进来的key的hashCode()值再进行一次运算。indexFor方法则是具体映射的方法。因为最后得到的这个值将走为存储Entry的索引。这里采用h &amp; (length - 1)的手法比较有意思。因为我们定义的数组长度为2的若干次方，这意味着如果我们取长度减一的值时，它的二进制数字是最高位以下的所有位为1.经过与运算之后它的结果肯定在0~2**x之间。就算前面hash方法计算出来的结果比数组长度大也没关系，因为这么一与运算，前面长出来的部分都变成0了。它这一步运算的效果相当于h % length;</p>
<p>　　有了这部分对数组长度调整和映射关系的理解，我们再来看具体的get, put方法就很容易了。</p>
<h2 id="五、HashMap-常用方法的实现"><a href="#五、HashMap-常用方法的实现" class="headerlink" title="五、HashMap 常用方法的实现"></a>五、HashMap 常用方法的实现</h2><p>1) <code>get</code>的实现<br>get方法的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </div><div class="line">        <span class="keyword">return</span> getForNullKey();  </div><div class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());  </div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];   </div><div class="line">    <span class="comment">// table[indexFor(hash, table.length)] 就是将indexFor运算得到的值直接映射到数组的索引  </span></div><div class="line">         e != <span class="keyword">null</span>;  </div><div class="line">         e = e.next) &#123;  </div><div class="line">         Object k;  </div><div class="line">         <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))  </div><div class="line">        <span class="comment">//找到hash值相同的情况下可能出现hash碰撞，所以需要调用equals方法来比较是否相等  </span></div><div class="line">            <span class="keyword">return</span> e.value;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　它这里就是一个映射，查找的过程。找到映射的点之后再和链表里的元素逐个比较，保证找到目标值。因为是hash表，会存在多个值映射到同一个index里面，所以这里还要和链表里的元素做对比。<br>​<br>​<br>2) <code>put</code>的实现<br>　　put元素就是一个放置元素的过程，首先也是找到对应的索引，然后再把元素放到链表里面去。如果链表里有和元素相同的，则更新对应的value，否则就放到链表头。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </div><div class="line">        <span class="keyword">return</span> putForNullKey(value);  </div><div class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());  </div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);  </div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  </div><div class="line">        Object k;  </div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </div><div class="line">        <span class="comment">//如果找到相同的值，更新，然后返回。  </span></div><div class="line">            V oldValue = e.value;  </div><div class="line">            e.value = value;  </div><div class="line">            e.recordAccess(<span class="keyword">this</span>);  </div><div class="line">            <span class="keyword">return</span> oldValue;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//在前面的循环里面没有找到，则新建一个Entry对象，加入到链表头。  </span></div><div class="line">    modCount++;  </div><div class="line">    addEntry(hash, key, value, i);  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　addEntry方法会判断表长度，如果达到一定的阀值则调整数组的长度，将其翻倍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;  </div><div class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];  </div><div class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);  </div><div class="line">        <span class="keyword">if</span> (size++ &gt;= threshold)  </div><div class="line">            resize(<span class="number">2</span> * table.length);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>3) <code>containsKey</code> 的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the entry associated with the specified key in the</div><div class="line"> * HashMap.  Returns null if the HashMap contains no mapping</div><div class="line"> * for the key.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3) <code>containsValue</code> 的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">           <span class="keyword">return</span> containsNullValue();</div><div class="line"></div><div class="line">Entry[] tab = table;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</div><div class="line">           <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</div><div class="line">               <span class="keyword">if</span> (value.equals(e.value))</div><div class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="六、Set接口、"><a href="#六、Set接口、" class="headerlink" title="六、Set接口、"></a>六、Set接口、</h2><p>Set接口里面主要定义了常用的集合操作方法，包括添加元素，判断元素是否在里面和对元素过滤。<br><strong>常用的几个方法如下：</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th style="text-align:center">方法详细定义</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>contains</td>
<td style="text-align:center">boolean contains(Object o);</td>
<td style="text-align:right">判断元素是否存在</td>
</tr>
<tr>
<td>add</td>
<td style="text-align:center">boolean add(E e);</td>
<td style="text-align:right">添加元素</td>
</tr>
<tr>
<td>remove</td>
<td style="text-align:center">boolean remove(Object o);</td>
<td style="text-align:right">删除元素</td>
</tr>
<tr>
<td>retainAll</td>
<td style="text-align:center">boolean retainAll(Collection&lt;?&gt; c);</td>
<td style="text-align:right">过滤元素</td>
</tr>
</tbody>
</table>
<p>我们知道，集合里面要求保存的元素是不能重复的，所以它里面所有的元素都是唯一的。它的定义就有点不太一样。</p>
<p><strong>HashSet</strong></p>
<p>　　HashSet是基于HashMap实现的，在它内部有如下的定义:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  </div><div class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map  </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div></pre></td></tr></table></figure></p>
<p>　　在它里面放置的元素都应到map里面的key部分，而在map中与key对应的value用一个Object()对象保存。因为内部是大量借用HashMap的实现，它本身不过是调用HashMap的一个代理，这些基本方法的实现就显得很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> map.containsKey(o);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　 在前面的参考资料里已经对HashMap做了一个很深入透彻的解析。这里在前人的基础上加入一点自己个人的理解体会。希望对以后使用类似的结构有一个更好的利用，也能够充分利用里面的设计思想。</p>
<hr>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>1) <strong>使用<code>transient</code> 关键字</strong></p>
<ol>
<li>transient 是表明该数据不参与序列化。因为 HashMap 中的存储数据的数组数据成员中，数组还有很多的空间没有被使用，没有被使用到的空间被序列化没有意义。所以需要手动使用 writeObject() 方法，只序列化实际存储元素的数组。</li>
<li>由于不同的虚拟机对于相同 hashCode 产生的 Code 值可能是不一样的，如果你使用默认的序列化，那么反序列化后，元素的位置和之前的是保持一致的，可是由于 hashCode 的值不一样了，那么定位函数 indexOf（）返回的元素下标就会不同，这样不是我们所想要的结果.</li>
</ol>
<p>2) <strong>私有 <code>writeObject</code> 和 <code>readObject</code> 方法</strong></p>
<p><strong>现象</strong><br>如果你有仔细阅读过HashMap的源码，那么你一定注意过一个问题：HashMap中有两个私有方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private void writeObject(java.io.ObjectOutputStream s) throws IOException</div><div class="line">private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException</div></pre></td></tr></table></figure></p>
<p>这两个方法有两个共同点：</p>
<ol>
<li>都是私有方法</li>
<li>虽然是私有方法，但是在HashMap内部却找不到任何调用它们的地方</li>
</ol>
<p><strong>疑问</strong><br>这两个方法是干嘛用的？<br>为什么要设置成私有的？</p>
<p><strong>解答</strong><br><strong>1) HashMap中的<code>writeObject</code>和<code>readObject</code>方法的作用是什么？</strong></p>
<p>答：<code>readObject</code>和<code>writeObject</code>方法都是为了HashMap的序列化而创建的。<br>首先，HashMap实现了Serializable接口，这意味着该类可以被序列化，而JDK提供的对于Java对象序列化操作的类是<code>ObjectOutputStream</code>，反序列化的类是<code>ObjectInputStream</code>。我们来看下序列化使用的ObjectOutputStream,它提供了不同的方法用来序列化不同类型的对象，比如<code>writeBoolean</code>,<code>wrietInt</code>,<code>writeLong</code>等，对于自定义类型，提供了<code>writeObject</code>方法。<br>ObjectOutputStream 的 writeObject 方法会调用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span> </span></div><div class="line">	<span class="keyword">throws</span> IOException </div><div class="line">    &#123;</div><div class="line">	ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</div><div class="line">	    ObjectStreamClass slotDesc = slots[i].desc;</div><div class="line">	    <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</div><div class="line">		PutFieldImpl oldPut = curPut;</div><div class="line">		curPut = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (extendedDebugInfo) &#123;</div><div class="line">		    debugInfoStack.push(</div><div class="line">			<span class="string">"custom writeObject data (class \""</span> + </div><div class="line">			slotDesc.getName() + <span class="string">"\")"</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">                SerialCallbackContext oldContext = curContext;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">                    curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</div><div class="line"></div><div class="line">		    bout.setBlockDataMode(<span class="keyword">true</span>);</div><div class="line">		    slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);</div><div class="line">		    bout.setBlockDataMode(<span class="keyword">false</span>);</div><div class="line">		    bout.writeByte(TC_ENDBLOCKDATA);</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    curContext.setUsed();</div><div class="line">                    curContext = oldContext;</div><div class="line"></div><div class="line">		    <span class="keyword">if</span> (extendedDebugInfo) &#123;</div><div class="line">			debugInfoStack.pop();</div><div class="line">		    &#125;	</div><div class="line">		&#125; </div><div class="line"></div><div class="line">		curPut = oldPut;</div><div class="line">	    &#125; <span class="keyword">else</span> &#123;</div><div class="line">		defaultWriteFields(obj, slotDesc);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，实际上在<code>ObjectOutputStream</code>中进行序列化操作的时候，会判断被序列化的对象是否自己重写了<code>writeObject</code>方法，如果重写了，就会调用被序列化对象自己的<code>writeObject</code>方法，如果没有重写，才会调用默认的序列化方法。<br>调用关系如下图：</p>
<p><strong>2) 为什么HashMap中的readObject和writeObject都是私有的？</strong></p>
<p>JDK文档中并没有明确说明设置为私有的原因。方法是私有的，那么该方法无法被子类override，这样做有什么好处呢？<br>如果我实现了一个继承HashMap的类，我也想有自己的序列化和反序列化方法，那我也可以实现私有的readObject和writeObject方法，而不用关心HashMap自己的那一部分。<br>下面的部分来自StackOverFlow:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">We don&apos;t want these methods to be overridden by subclasses. Instead, each class can have its own writeObject method, and the serialization engine will call all of them one after the other. This is only possible with private methods (these are not overridden). (The same is valid for readObject.)</div></pre></td></tr></table></figure>
<p><strong>3)为什么HashMap要自己实现writeObject和readObject方法，而不是使用JDK统一的默认序列化和反序列化操作呢？</strong></p>
<ol>
<li>首先要明确序列化的目的，将java对象序列化，一定是为了在某个时刻能够将该对象反序列化，而且一般来讲序列化和反序列化所在的机器是不同的，因为序列化最常用的场景就是跨机器的调用，而序列化和反序列化的一个最基本的要求就是，反序列化之后的对象与序列化之前的对象是一致的。</li>
<li>HashMap中，由于Entry的存放位置是根据Key的Hash值来计算，然后存放到数组中的，对于同一个Key，在不同的JVM实现中计算得出的Hash值可能是不同的。</li>
<li>Hash值不同导致的结果就是：有可能一个HashMap对象的反序列化结果与序列化之前的结果不一致。即有可能序列化之前，Key=’AAA’的元素放在数组的第0个位置，而反序列化值后，根据Key获取元素的时候，可能需要从数组为2的位置来获取，而此时获取到的数据与序列化之前肯定是不同的。</li>
</ol>
<p><strong>在《Effective Java》中，Joshua大神对此有所解释:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">For example, consider the case of a hash table. The physical representation is a sequence of hash buckets containing key-value entries. The bucket that an entry resides in is a function of the hash code of its key, which is not, in general, guaranteed to be the same from JVM implementation to JVM implementation. In fact, it isn&apos;t even guaranteed to be the same from run to run. Therefore, accepting the default serialized form for a hash table would constitute a serious bug. Serializing and deserializing the hash table could yield an object whose invariants were seriously corrupt.</div></pre></td></tr></table></figure>
<p><strong>所以为了避免这个问题，HashMap采用了下面的方式来解决：</strong></p>
<ol>
<li>将可能会造成数据不一致的元素使用transient关键字修饰，从而避免JDK中默认序列化方法对该对象的序列化操作。不序列化的包括：Entry[] table,size,modCount。 </li>
<li>自己实现writeObject方法，从而保证序列化和反序列化结果的一致性。</li>
</ol>
<p><strong>4) 那么，HashMap又是通过什么手段来保证序列化和反序列化数据的一致性的呢？</strong></p>
<p>首先，HashMap序列化的时候不会将保存数据的数组序列化，而是将元素个数以及每个元素的Key和Value都进行序列化。<br>在反序列化的时候，重新计算Key和Value的位置，重新填充一个数组。<br>想想看，是不是能够解决序列化和反序列化不一致的情况呢？<br>由于不序列化存放元素的Entry数组，而是反序列化的时候重新生成，这样就避免了反序列化之后根据Key获取到的元素与序列化之前获取到的元素不同。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/22/Java_thread/lock/" rel="next" title="Java线程之Lock">
                <i class="fa fa-chevron-left"></i> Java线程之Lock
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/26/Java_collection/serialization/" rel="prev" title="深入理解Java对象序列化">
                深入理解Java对象序列化 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Jianzhao Chen" />
          <p class="site-author-name" itemprop="name">Jianzhao Chen</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">127</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、HashMap概述："><span class="nav-text">一、HashMap概述：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、HashMap的数据结构："><span class="nav-text">二、HashMap的数据结构：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、数组增长调整（Rehashing）"><span class="nav-text">三、数组增长调整（Rehashing）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、详细映射过程"><span class="nav-text">四、详细映射过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、HashMap-常用方法的实现"><span class="nav-text">五、HashMap 常用方法的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、Set接口、"><span class="nav-text">六、Set接口、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充"><span class="nav-text">补充</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jianzhao Chen</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://chenjianzhao.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2017/03/25/Java_collection/HashMap/';
          this.page.identifier = '2017/03/25/Java_collection/HashMap/';
          this.page.title = 'Java集合类深入分析之HashMap(jdk1.6中的实现)';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://chenjianzhao.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  





  






  





  

  

  

  

</body>
</html>
