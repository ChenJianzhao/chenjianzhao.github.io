<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="原文：Redis Sentinel机制与用法（一）
概述Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 之 Sentinel">
<meta property="og:url" content="http://yoursite.com/2017/07/18/Redis/sentinel/index.html">
<meta property="og:site_name" content="Pandora">
<meta property="og:description" content="原文：Redis Sentinel机制与用法（一）
概述Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能">
<meta property="og:updated_time" content="2017-11-06T00:34:00.331Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis 之 Sentinel">
<meta name="twitter:description" content="原文：Redis Sentinel机制与用法（一）
概述Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/07/18/Redis/sentinel/"/>





  <title> Redis 之 Sentinel | Pandora </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Pandora</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/18/Redis/sentinel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jianzhao Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pandora">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Redis 之 Sentinel
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-18T20:00:00+08:00">
                2017-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/18/Redis/sentinel/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/07/18/Redis/sentinel/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>原文：<a href="https://segmentfault.com/a/1190000002680804" target="_blank" rel="external">Redis Sentinel机制与用法（一）</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis-Sentinel是Redis官方推荐的<strong>高可用性(HA)解决方案</strong>，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自懂切换。</p>
<p>它的主要功能有以下几点</p>
<ul>
<li><p>不时地监控redis是否按照预期良好地运行;</p>
</li>
<li><p>如果发现某个redis节点运行出现状况，能够通知另外一个进程(例如它的客户端);</p>
</li>
<li><p>能够进行自动切换。当一个master节点不可用时，能够选举出master的多个slave(如果有超过一个slave的话)中的一个来作为新的master,其它的slave节点会将它所追随的master的地址改为被提升为master的slave的新地址。</p>
<p>​</p>
</li>
</ul>
<a id="more"></a>
<h2 id="Sentinel支持集群"><a href="#Sentinel支持集群" class="headerlink" title="Sentinel支持集群"></a>Sentinel支持集群</h2><p>很显然，只使用单个sentinel进程来监控redis集群是不可靠的，当sentinel进程宕掉后(sentinel本身也有单点问题，single-point-of-failure)整个集群系统将无法按照预期的方式运行。所以有必要将sentinel集群，</p>
<p><strong>这样有几个好处：</strong></p>
<ul>
<li>即使有一些sentinel进程宕掉了，依然可以进行redis集群的主备切换；</li>
<li>如果只有一个sentinel进程，如果这个进程运行出错，或者是网络堵塞，那么将无法实现redis集群的主备切换（单点问题）;</li>
<li>如果有多个sentinel，redis的客户端可以随意地连接任意一个sentinel来获得关于redis集群中的信息。</li>
</ul>
<h2 id="运行Sentinel"><a href="#运行Sentinel" class="headerlink" title="运行Sentinel"></a>运行Sentinel</h2><p>运行sentinel有两种方式：</p>
<ul>
<li><p>第一种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-sentinel ./sentinel1/sentinel.conf</div></pre></td></tr></table></figure>
</li>
<li><p>第二种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server ./sentinel1/sentinel.conf --sentinel</div></pre></td></tr></table></figure>
<p>以上两种方式，都必须指定一个sentinel的配置文件sentinel.conf，如果不指定，将无法启动sentinel。sentinel默认监听<code>26379端口</code>，所以运行前必须确定该端口没有被别的进程占用。</p>
<p>​</p>
</li>
</ul>
<h2 id="Sentinel的配置"><a href="#Sentinel的配置" class="headerlink" title="Sentinel的配置"></a>Sentinel的配置</h2><p>Redis源码包中包含了一个sentinel.conf文件作为sentinel的配置文件，配置文件自带了关于各个配置项的解释。典型的配置项如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sentinel monitor mymaster 127.0.0.1 6379 2</div><div class="line">sentinel down-after-milliseconds mymaster 60000</div><div class="line">sentinel failover-timeout mymaster 180000</div><div class="line">sentinel parallel-syncs mymaster 1</div><div class="line"></div><div class="line">## Question：为什么可以配置多个Master？？ 不同的集群？？</div><div class="line">sentinel monitor resque 192.168.1.3 6380 4</div><div class="line">sentinel down-after-milliseconds resque 10000</div><div class="line">sentinel failover-timeout resque 180000</div><div class="line">sentinel parallel-syncs resque 5</div></pre></td></tr></table></figure>
<ul>
<li><p>上面的配置项配置了两个名字分别为 “mymaster” 和 “resque” 的 master，配置文件只需要配置master的信息就好啦，不用配置slave的信息，因为 <strong>slave能够被自动检测到(master节点会有关于slave的消息)</strong>。</p>
</li>
<li><p>需要注意的是，<strong>配置文件在sentinel运行期间是会被动态修改的</strong>，例如当发生主备切换时候，配置文件中的master会被修改为另外一个slave。这样，之后sentinel如果重启时，就可以根据这个配置来恢复其之前所监控的redis集群的状态。</p>
<blockquote>
<p>Question：需要配置什么才能自动保存修改？实践中并不会保存到磁盘</p>
<p>补充：实践中，新版本在 Linux 是可以动态修改并写回配置文件的，Windows 下不生效。</p>
</blockquote>
</li>
</ul>
<p><strong>接下来我们将一行一行地解释上面的配置项</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sentinel monitor mymaster 127.0.0.1 6379 2</div></pre></td></tr></table></figure>
<ul>
<li><p>这一行代表sentinel监控的master的名字叫做<strong>mymaster</strong> ，地址为<strong>127.0.0.1:6379</strong></p>
</li>
<li><p>行尾最后的一个<strong>2</strong>代表什么意思呢？我们知道，网络是不可靠的，有时候一个sentinel会因为网络堵塞而误以为一个master redis已经死掉了，当sentinel集群式，解决这个问题的方法就变得很简单，只需要多个sentinel互相沟通来确认某个master是否真的死了，<strong>这个2代表，当集群中有2个sentinel认为master死了时，才能真正认为该master已经不可用了</strong>。</p>
<p><strong>（sentinel集群中各个sentinel也有互相通信，通过gossip协议）</strong></p>
</li>
</ul>
<p><strong>除了第一行配置，我们发现剩下的配置都有一个统一的格式:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sentinel &lt;option_name&gt; &lt;master_name&gt; &lt;option_value&gt;</div></pre></td></tr></table></figure>
<p>接下来我们根据上面格式中的<strong>option_name</strong>一个一个来解释这些配置项：</p>
<ul>
<li><strong>down-after-milliseconds</strong><br>sentinel会向master发送心跳<strong>PING</strong>来确认master是否存活，如果master在<strong>“一定时间范围”</strong>内不回应<strong>PONG</strong> 或者是回复了一个错误消息，那么这个sentinel会<strong>主观地</strong>(单方面地)认为这个master已经不可用了(subjectively down, 也简称为<code>SDOWN</code>)。而这个down-after-milliseconds就是用来指定这个<strong>“一定时间范围”</strong>的，单位是毫秒。</li>
</ul>
<blockquote>
<p>不过需要注意的是，这个时候sentinel并不会马上进行failover主备切换，这个sentinel还需要参考sentinel集群中其他sentinel的意见，如果超过某个数量的sentinel也<strong>主观地</strong>认为该master死了，那么这个master就会被<strong>客观地</strong>(注意哦，这次不是主观，是客观，与刚才的subjectively down相对，这次是objectively down，简称为<code>ODOWN</code>)认为已经死了。需要一起做出决定的sentinel数量在上一条配置中进行配置。</p>
</blockquote>
<ul>
<li><p><strong>parallel-syncs</strong><br>在发生failover主备切换时，这个选项指定了最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave处于不能处理命令请求的状态。</p>
<p>​</p>
</li>
</ul>
<p>其他配置项在sentinel.conf中都有很详细的解释。<br>所有的配置都可以在运行时用命令<code>SENTINEL SET command</code><strong>动态修改。</strong></p>
<ul>
<li><strong>failover-timeout</strong>  见以下小节</li>
</ul>
<h2 id="Sentinel的“仲裁会”"><a href="#Sentinel的“仲裁会”" class="headerlink" title="Sentinel的“仲裁会”"></a>Sentinel的“仲裁会”</h2><ul>
<li>前面我们谈到，当一个master被sentinel集群监控时，需要为它指定一个参数，这个参数指定了当需要判决master为不可用，并且进行failover时，所需要的sentinel数量，本文中我们暂时称这个参数为<strong>票数</strong></li>
<li>不过，当failover主备切换真正被触发后，failover并不会马上进行，还需要sentinel中的<strong>大多数</strong>sentinel授权后才可以进行failover。</li>
<li>当<code>ODOWN</code>时，failover被触发。<code>failover</code>一旦被触发，尝试去进行failover的sentinel会去获得“大多数”sentinel的授权（如果票数比大多数还要大的时候，则询问更多的sentinel)</li>
<li>这个区别看起来很微妙，但是很容易理解和使用。例如，集群中有5个sentinel，票数被设置为2，当2个sentinel认为一个master已经不可用了以后，将会触发failover，但是，进行failover的那个sentinel必须先获得至少3个sentinel的授权才可以实行failover。</li>
<li>如果票数被设置为5，要达到ODOWN状态，必须所有5个sentinel都主观认为master为不可用，要进行failover，那么得获得所有5个sentinel的授权。</li>
</ul>
<h2 id="配置版本号"><a href="#配置版本号" class="headerlink" title="配置版本号"></a>配置版本号</h2><p>（Question: 原文描述有错误？：勘误: sentinel集群都遵守一个规则：如果sentinel 推荐sentinel B去执行failover，<del>B会等待一段时间后</del>，自行再次去对同一个master执行failover，这个等待的时间是通过<code>failover-timeout</code>配置项去配置的。）</p>
<ul>
<li>为什么要先获得<strong>大多数</strong>sentinel的认可时才能真正去执行failover呢？</li>
<li>当一个sentinel被授权后，它将会获得宕掉的master的一份最新配置版本号，当failover执行结束以后，这个版本号将会被用于最新的配置。因为<strong>大多数</strong>sentinel都已经知道该版本号已经被要执行failover的sentinel拿走了，所以其他的sentinel都不能再去使用这个版本号。这意味着，每次failover都会附带有一个独一无二的版本号。我们将会看到这样做的重要性。</li>
<li>而且，sentinel集群都遵守一个规则：如果sentinel A推荐sentinel B去执行failover，A会等待一段时间后，自行再次去对同一个master执行failover，这个等待的时间是通过 <code>failover-timeout</code> 配置项去配置的。从这个规则可以看出，sentinel集群中的sentinel不会再同一时刻并发去failover同一个master，第一个进行failover的sentinel如果失败了，另外一个将会在一定时间内进行重新进行failover，以此类推。</li>
</ul>
<p><strong>redis sentinel保证了活跃性</strong>：如果<strong>大多数</strong>sentinel能够互相通信，最终将会有一个被授权去进行failover.<br><strong>redis sentinel保证了安全性</strong>：每个试图去failover同一个master的sentinel都会得到一个独一无二的版本号。</p>
<h2 id="配置传播"><a href="#配置传播" class="headerlink" title="配置传播"></a>配置传播</h2><ul>
<li>一旦一个sentinel成功地对一个master进行了failover，它将会把关于master的最新配置通过广播形式通知其它sentinel，其它的sentinel则更新对应master的配置。</li>
<li>一个faiover要想被成功实行，sentinel必须能够向选为master的slave发送<code>SLAVE OF NO ONE</code>命令，然后能够通过<code>INFO</code>命令看到新master的配置信息。</li>
<li>当将一个slave选举为master并发送 <code>SLAVE OF NO ONE</code>后，即使其它的slave还没针对新master重新配置自己，failover也被认为是成功了的，然后所有sentinels将会发布新的配置信息。</li>
<li>新配在集群中相互传播的方式，就是为什么我们需要当一个sentinel进行failover时必须被授权一个版本号的原因。</li>
<li>每个sentinel使用 <strong>发布/订阅</strong> 的方式持续地传播master的配置版本信息，配置传播的 <strong>发布/订阅</strong> 管道是：<code>__sentinel__:hello</code>。</li>
<li>因为每一个配置都有一个版本号，所以以<strong>版本号最大的那个为标准</strong>。</li>
</ul>
<blockquote>
<p>举个栗子：假设有一个名为 mymaster 的地址为192.168.1.50:6379。一开始，集群中所有的sentinel都知道这个地址，于是为mymaster的配置打上版本号1。一段时候后mymaster死了，有一个sentinel被授权用版本号2对其进行failover。如果failover成功了，假设地址改为了192.168.1.50:9000，此时配置的版本号为2，进行failover的sentinel会将新配置广播给其他的sentinel，由于其他sentinel维护的版本号为1，发现新配置的版本号为2时，版本号变大了，说明配置更新了，于是就会采用最新的版本号为2的配置。</p>
</blockquote>
<p>这意味着sentinel集群保证了第二种活跃性：一个能够互相通信的sentinel集群最终会采用版本号最高且相同的配置。</p>
<h2 id="SDOWN和ODOWN的更多细节"><a href="#SDOWN和ODOWN的更多细节" class="headerlink" title="SDOWN和ODOWN的更多细节"></a>SDOWN和ODOWN的更多细节</h2><ul>
<li>sentinel对于<strong>不可用</strong>有两种不同的看法，一个叫 <code>主观不可用(SDOWN)</code>,另外一个叫 <code>客观不可用(ODOWN)</code>。SDOWN是sentinel自己主观上检测到的关于master的状态，ODOWN需要一定数量的sentinel达成一致意见才能认为一个master客观上已经宕掉，</li>
<li>各个sentinel之间通过命令<code>SENTINEL is_master_down_by_addr</code>来获得其它sentinel对master的检测结果。</li>
<li>从sentinel的角度来看，如果发送了<strong>PING</strong>心跳后，在一定时间内没有收到合法的回复，就达到了SDOWN的条件。这个时间在配置中通过<code>is-master-down-after-milliseconds</code>参数配置。</li>
<li>当sentinel发送<strong>PING</strong>后，以下回复之一都被认为是合法的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PING replied with +PONG.</div><div class="line">PING replied with -LOADING error.</div><div class="line">PING replied with -MASTERDOWN error.</div></pre></td></tr></table></figure>
<ul>
<li>其它任何回复（或者根本没有回复）都是不合法的。</li>
<li>从<code>SDOWN</code>切换到<code>ODOWN</code>不需要任何一致性算法，只需要一个<code>gossip协议</code>：如果一个sentinel收到了足够多的sentinel发来消息告诉它某个master已经down掉了，SDOWN状态就会变成ODOWN状态。如果之后master可用了，这个状态就会相应地被清理掉。</li>
<li>正如之前已经解释过了，真正进行failover需要一个授权的过程，但是所有的failover都开始于一个ODOWN状态。</li>
<li>ODOWN状态只适用于master，对于不是master的redis节点sentinel之间不需要任何协商，slaves和sentinel不会有ODOWN状态。</li>
</ul>
<h2 id="Sentinel之间和Slaves之间的自动发现机制"><a href="#Sentinel之间和Slaves之间的自动发现机制" class="headerlink" title="Sentinel之间和Slaves之间的自动发现机制"></a>Sentinel之间和Slaves之间的自动发现机制</h2><ul>
<li>虽然sentinel集群中各个sentinel都互相连接彼此来检查对方的可用性以及互相发送消息。但是你不用在任何一个sentinel配置任何其它的sentinel的节点。因为sentinel利用了master的<strong>发布/订阅</strong>机制去自动发现其它也监控了统一master的sentinel节点。</li>
<li>通过向名为<code>__sentinel__:hello</code>的管道中发送消息来实现。</li>
<li>同样，你也不需要在sentinel中配置某个master的所有slave的地址，sentinel会通过询问master来得到这些slave的地址的。</li>
<li>每个sentinel通过向每个master和slave的<strong>发布/订阅</strong>频道<code>__sentinel__:hello</code>每秒发送一次消息，来宣布它的存在。</li>
<li>每个sentinel也订阅了每个master和slave的频道<code>__sentinel__:hello</code>的内容，来发现未知的sentinel，<strong>当检测到了新的sentinel，则将其加入到自身维护的master监控列表中</strong>。</li>
<li>每个sentinel发送的消息中也包含了其当前维护的最新的master配置。如果某个sentinel发现自己的配置版本低于接收到的配置版本，则会<strong>用新的配置更新自己的master配置</strong>。</li>
<li>在为一个master添加一个新的sentinel前，sentinel总是检查是否已经有sentinel与新的sentinel的进程号或者是地址是一样的。如果是那样，<strong>这个sentinel将会被删除，而把新的sentinel添加上去</strong>。</li>
</ul>
<h2 id="网络隔离时的一致性"><a href="#网络隔离时的一致性" class="headerlink" title="网络隔离时的一致性"></a>网络隔离时的一致性</h2><p>redis sentinel集群的配置的一致性模型为最终一致性，集群中每个sentinel最终都会采用最高版本的配置。然而，在实际的应用环境中，有三个不同的角色会与sentinel打交道：</p>
<ul>
<li>Redis实例.</li>
<li>Sentinel实例.</li>
<li>客户端.</li>
</ul>
<p>为了考察整个系统的行为我们必须同时考虑到这三个角色。</p>
<p>下面有个简单的例子，有三个主机，每个主机分别运行一个redis和一个sentinel:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">            +-------------+</div><div class="line">            | Sentinel 1  | &lt;--- Client A</div><div class="line">            | Redis 1 (M) |</div><div class="line">            +-------------+</div><div class="line">                    |</div><div class="line">                    |</div><div class="line">+-------------+     |                     +------------+</div><div class="line">| Sentinel 2  |-----+-- / partition / ----| Sentinel 3 | &lt;--- Client B</div><div class="line">| Redis 2 (S) |                           | Redis 3 (M)|</div><div class="line">+-------------+                           +------------+</div></pre></td></tr></table></figure>
<p>在这个系统中，初始状态下redis3是master, redis1和redis2是slave。之后redis3所在的主机网络不可用了，sentinel1和sentinel2启动了failover并把redis1选举为master。</p>
<p>Sentinel集群的特性保证了sentinel1和sentinel2得到了关于master的最新配置。但是sentinel3依然持着的是就的配置，因为它与外界隔离了。</p>
<p>当网络恢复以后，我们知道sentinel3将会更新它的配置。但是，如果客户端所连接的master被网络隔离，会发生什么呢？</p>
<p>客户端将依然可以向redis3写数据，但是当网络恢复后，redis3就会变成redis的一个slave，那么，在网络隔离期间，客户端向redis3写的数据将会丢失。</p>
<p>也许你不会希望这个场景发生：</p>
<ul>
<li>如果你把redis当做缓存来使用，那么你也许能容忍这部分数据的丢失。</li>
<li>但如果你把redis当做一个存储系统来使用，你也许就无法容忍这部分数据的丢失了。</li>
</ul>
<p>因为redis采用的是异步复制，在这样的场景下，没有办法避免数据的丢失。然而，你可以通过以下配置来配置redis3和redis1，<strong>使得数据不会丢失</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">min-slaves-to-write 1</div><div class="line">min-slaves-max-lag 10</div></pre></td></tr></table></figure>
<ul>
<li><strong>min-slaves-to-write</strong> 指定了slave的数量</li>
</ul>
<p>通过上面的配置，当一个redis是master时，如果它不能向至少一个slave写数据，它将会拒绝接受客户端的写请求。</p>
<ul>
<li><strong>min-slaves-max-lag</strong> 指定了slave 最长响应时间</li>
</ul>
<p>由于复制是异步的，master无法向slave写数据意味着slave要么断开连接了，要么不在指定时间内向master发送同步数据的请求了</p>
<h2 id="Sentinel状态持久化"><a href="#Sentinel状态持久化" class="headerlink" title="Sentinel状态持久化"></a>Sentinel状态持久化</h2><p>snetinel的状态会被持久化地写入sentinel的配置文件中。每次当收到一个新的配置时，或者新创建一个配置时，配置会被持久化到硬盘中，并带上配置的版本戳。这意味着，可以安全的停止和重启sentinel进程。</p>
<p>（Question：实践中没有持久化？？）</p>
<h2 id="无failover时的配置纠正"><a href="#无failover时的配置纠正" class="headerlink" title="无failover时的配置纠正"></a>无failover时的配置纠正</h2><p>即使当前没有failover正在进行，sentinel依然会使用当前配置去设置监控的master。特别是：</p>
<ul>
<li>根据最新配置确认为slaves的节点却声称自己是master(参考上文例子中被网络隔离后的的redis3)，这时它们会被重新配置为当前master的slave。</li>
<li>如果slaves连接了一个错误的master，将会被改正过来，连接到正确的master。</li>
</ul>
<h2 id="Slave选举与优先级"><a href="#Slave选举与优先级" class="headerlink" title="Slave选举与优先级"></a>Slave选举与优先级</h2><p>当一个sentinel准备好了要进行failover，并且收到了其他sentinel的授权，那么就需要选举出一个合适的slave来做为新的master。</p>
<p>slave的选举主要会评估slave的以下几个方面：</p>
<ul>
<li>与master断开连接的次数</li>
<li>Slave的优先级</li>
<li>数据复制的下标(用来评估slave当前拥有多少master的数据)</li>
<li>进程ID</li>
</ul>
<p><strong>与master断开连接的次数</strong></p>
<p>如果一个slave与master失去联系超过10次，并且每次都超过了配置的最大失联时间(<code>down-after-milliseconds option</code>)，并且，如果sentinel在进行failover时发现slave失联，那么这个slave就会被sentinel认为不适合用来做新master的。</p>
<p>更严格的定义是，如果一个slave持续断开连接的时间超过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</div></pre></td></tr></table></figure>
<p>就会被认为失去选举资格。</p>
<p><strong>Slave的优先级</strong></p>
<p>符合上述条件的slave才会被列入master候选人列表，并根据以下顺序来进行排序：</p>
<ol>
<li>sentinel首先会根据slaves的优先级来进行排序，优先级越小排名越靠前（？）。</li>
<li>如果优先级相同，则查看复制的下标，哪个从master接收的复制数据多，哪个就靠前。</li>
<li>如果优先级和下标都相同，就选择进程ID较小的那个。</li>
</ol>
<p><strong>注：</strong>一个redis无论是master还是slave，都必须在配置中指定一个slave优先级。要注意到master也是有可能通过failover变成slave的。</p>
<p>如果一个redis的slave优先级配置为0，那么它将永远不会被选为master。但是它依然会从master哪里复制数据。</p>
<h2 id="Sentinel和Redis身份验证"><a href="#Sentinel和Redis身份验证" class="headerlink" title="Sentinel和Redis身份验证"></a>Sentinel和Redis身份验证</h2><p>当一个master配置为需要密码才能连接时，客户端和slave在连接时都需要提供密码。</p>
<p>master通过<code>requirepass</code>设置自身的密码，不提供密码无法连接到这个master。<br>slave通过<code>masterauth</code>来设置访问master时的密码。</p>
<p>但是当使用了sentinel时，由于一个master可能会变成一个slave，一个slave也可能会变成master，所以需要同时设置上述两个配置项。</p>
<h2 id="Sentinel-API"><a href="#Sentinel-API" class="headerlink" title="Sentinel API"></a>Sentinel API</h2><p>Sentinel默认运行在26379端口上，sentinel支持redis协议，所以可以使用redis-cli客户端或者其他可用的客户端来与sentinel通信。</p>
<p>有两种方式能够与sentinel通信：</p>
<ul>
<li>一种是直接使用客户端向它发消息</li>
<li>另外一种是使用<strong>发布/订阅</strong>模式来订阅sentinel事件，比如说failover，或者某个redis实例运行出错，等等。</li>
</ul>
<h3 id="Sentinel命令"><a href="#Sentinel命令" class="headerlink" title="Sentinel命令"></a>Sentinel命令</h3><p>sentinel支持的合法命令如下：</p>
<ul>
<li><code>PING</code> sentinel回复<code>PONG</code>.</li>
<li><code>SENTINEL masters</code> 显示被监控的所有master以及它们的状态.</li>
<li><code>SENTINEL master &lt;master name&gt;</code> 显示指定master的信息和状态；</li>
<li><code>SENTINEL slaves &lt;master name&gt;</code> 显示指定master的所有slave以及它们的状态；</li>
<li><code>SENTINEL get-master-addr-by-name &lt;master name&gt;</code> 返回指定master的ip和端口，如果正在进行failover或者failover已经完成，将会显示被提升为master的slave的ip和端口。</li>
<li><code>SENTINEL reset &lt;pattern&gt;</code> 重置名字匹配该正则表达式的所有的master的状态信息，清楚其之前的状态信息，以及slaves信息。</li>
<li><code>SENTINEL failover &lt;master name&gt;</code> 强制sentinel执行failover，并且不需要得到其他sentinel的同意。但是failover后会将最新的配置发送给其他sentinel。</li>
</ul>
<h3 id="动态修改Sentinel配置"><a href="#动态修改Sentinel配置" class="headerlink" title="动态修改Sentinel配置"></a>动态修改Sentinel配置</h3><p>从redis2.8.4开始，sentinel提供了一组API用来添加，删除，修改master的配置。</p>
<blockquote>
<p>需要注意的是，如果你通过API修改了一个sentinel的配置，sentinel不会把修改的配置告诉其他sentinel。你需要自己手动地对多个sentinel发送修改配置的命令。</p>
</blockquote>
<p>以下是一些修改sentinel配置的命令：</p>
<ul>
<li><code>SENTINEL MONITOR &lt;name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</code>这个命令告诉sentinel去<strong>监听一个新的master</strong></li>
<li><code>SENTINEL REMOVE &lt;name&gt;</code> 命令sentine<strong>l放弃对某个master的监听</strong></li>
<li><code>SENTINEL SET &lt;name&gt; &lt;option&gt; &lt;value&gt;</code> 这个命令很像Redis的<code>CONFIG SET</code>命令，用来改变指定master的配置。支持多个<option><value>。例如以下实例：</value></option></li>
<li><code>SENTINEL SET objects-cache-master down-after-milliseconds 1000</code></li>
</ul>
<p>只要是配置文件中存在的配置项，都可以用<code>SENTINEL SET</code>命令来设置。这个还可以用来设置master的属性，比如说quorum(票数)，而不需要先删除master，再重新添加master。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SENTINEL SET objects-cache-master quorum 5</div></pre></td></tr></table></figure>
<h3 id="增加或删除Sentinel"><a href="#增加或删除Sentinel" class="headerlink" title="增加或删除Sentinel"></a>增加或删除Sentinel</h3><p>由于有sentinel自动发现机制，所以添加一个sentinel到你的集群中非常容易，你所需要做的只是监控到某个Master上，然后新添加的sentinel就能获得其他sentinel的信息以及masterd所有的slave。</p>
<p>如果你需要添加多个sentinel，建议你一个接着一个添加，这样可以预防网络隔离带来的问题。你可以每个30秒添加一个sentinel。最后你可以用<code>SENTINEL MASTER mastername</code>来检查一下是否所有的sentinel都已经监控到了master。</p>
<p><strong>删除一个sentinel显得有点复杂</strong>：因为sentinel永远不会删除一个已经存在过的sentinel，即使它已经与组织失去联系很久了。要想删除一个sentinel，应该遵循如下步骤：</p>
<ol>
<li>停止所要删除的sentinel</li>
<li>发送一个<code>SENTINEL RESET *</code>命令给所有其它的sentinel实例，如果你想要重置指定master上面的sentinel，只需要把*号改为特定的名字，注意，需要一个接一个发，每次发送的间隔不低于30秒。</li>
<li>检查一下所有的sentinels是否都有一致的当前sentinel数。使用<code>SENTINEL MASTER mastername</code> 来查询。</li>
</ol>
<h3 id="删除旧master或者不可达slave"><a href="#删除旧master或者不可达slave" class="headerlink" title="删除旧master或者不可达slave"></a>删除旧master或者不可达slave</h3><p>sentinel永远会记录好一个Master的slaves，即使slave已经与组织失联好久了。这是很有用的，因为sentinel集群必须有能力把一个恢复可用的slave进行重新配置。</p>
<p>并且，failover后，失效的master将会被标记为新master的一个slave，这样的话，当它变得可用时，就会从新master上复制数据。</p>
<p>然后，有时候你想要永久地删除掉一个slave(有可能它曾经是个master)，你只需要发送一个<code>SENTINEL RESET master</code>命令给所有的sentinels，它们将会更新列表里能够正确地复制master数据的slave。</p>
<h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><p>客户端可以向一个sentinel发送订阅某个频道的事件的命令，当有特定的事件发生时，sentinel会通知所有订阅的客户端。需要注意的是客户端只能订阅，不能发布。</p>
<p>订阅频道的名字与事件的名字一致。例如，频道名为<strong>sdown</strong> 将会发布所有与SDOWN相关的消息给订阅者。</p>
<p>如果想要订阅所有消息，只需简单地使用<code>PSUBSCRIBE *</code></p>
<p>以下是所有你可以收到的消息的消息格式，如果你订阅了所有消息的话。第一个单词是频道的名字，其它是数据的格式。</p>
<p>注意：以下的instance details的格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;instance-type&gt; &lt;name&gt; &lt;ip&gt; &lt;port&gt; @ &lt;master-name&gt; &lt;master-ip&gt; &lt;master-port&gt;</div></pre></td></tr></table></figure>
<p>如果这个redis实例是一个master，那么@之后的消息就不会显示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+reset-master &lt;instance details&gt; -- 当master被重置时.</div><div class="line">+slave &lt;instance details&gt; -- 当检测到一个slave并添加进slave列表时.</div><div class="line">+failover-state-reconf-slaves &lt;instance details&gt; -- Failover状态变为reconf-slaves状态时</div><div class="line">+failover-detected &lt;instance details&gt; -- 当failover发生时</div><div class="line">+slave-reconf-sent &lt;instance details&gt; -- sentinel发送SLAVEOF命令把它重新配置时</div><div class="line">+slave-reconf-inprog &lt;instance details&gt; -- slave被重新配置为另外一个master的slave，但数据复制还未发生时。</div><div class="line">+slave-reconf-done &lt;instance details&gt; -- slave被重新配置为另外一个master的slave并且数据复制已经与master同步时。</div><div class="line">-dup-sentinel &lt;instance details&gt; -- 删除指定master上的冗余sentinel时 (当一个sentinel重新启动时，可能会发生这个事件).</div><div class="line">+sentinel &lt;instance details&gt; -- 当master增加了一个sentinel时。</div><div class="line">+sdown &lt;instance details&gt; -- 进入SDOWN状态时;</div><div class="line">-sdown &lt;instance details&gt; -- 离开SDOWN状态时。</div><div class="line">+odown &lt;instance details&gt; -- 进入ODOWN状态时。</div><div class="line">-odown &lt;instance details&gt; -- 离开ODOWN状态时。</div><div class="line">+new-epoch &lt;instance details&gt; -- 当前配置版本被更新时。</div><div class="line">+try-failover &lt;instance details&gt; -- 达到failover条件，正等待其他sentinel的选举。</div><div class="line">+elected-leader &lt;instance details&gt; -- 被选举为去执行failover的时候。</div><div class="line">+failover-state-select-slave &lt;instance details&gt; -- 开始要选择一个slave当选新master时。</div><div class="line">no-good-slave &lt;instance details&gt; -- 没有合适的slave来担当新master</div><div class="line">selected-slave &lt;instance details&gt; -- 找到了一个适合的slave来担当新master</div><div class="line">failover-state-send-slaveof-noone &lt;instance details&gt; -- 当把选择为新master的slave的身份进行切换的时候。</div><div class="line">failover-end-for-timeout &lt;instance details&gt; -- failover由于超时而失败时。</div><div class="line">failover-end &lt;instance details&gt; -- failover成功完成时。</div><div class="line">switch-master &lt;master name&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt; -- 当master的地址发生变化时。通常这是客户端最感兴趣的消息了。</div><div class="line">+tilt -- 进入Tilt模式。</div><div class="line">-tilt -- 退出Tilt模式。</div></pre></td></tr></table></figure>
<h3 id="TILT-模式"><a href="#TILT-模式" class="headerlink" title="TILT 模式"></a>TILT 模式</h3><p>redis sentinel非常依赖系统时间，例如它会使用系统时间来判断一个PING回复用了多久的时间。<br>然而，假如系统时间被修改了，或者是系统十分繁忙，或者是进程堵塞了，sentinel可能会出现运行不正常的情况。<br>当系统的稳定性下降时，TILT模式是sentinel可以进入的一种的保护模式。当进入TILT模式时，sentinel会继续监控工作，但是它不会有任何其他动作，它也不会去回应<code>is-master-down-by-addr</code>这样的命令了，因为它在TILT模式下，检测失效节点的能力已经变得让人不可信任了。<br>如果系统恢复正常，持续30秒钟，sentinel就会退出TITL模式。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/17/Redis/safe/" rel="next" title="Redis 之 持久化与复制">
                <i class="fa fa-chevron-left"></i> Redis 之 持久化与复制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/18/Redis/sentinel2/" rel="prev" title="Redis 之 Sentinel实操">
                Redis 之 Sentinel实操 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Jianzhao Chen" />
          <p class="site-author-name" itemprop="name">Jianzhao Chen</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">126</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sentinel支持集群"><span class="nav-text">Sentinel支持集群</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行Sentinel"><span class="nav-text">运行Sentinel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sentinel的配置"><span class="nav-text">Sentinel的配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sentinel的“仲裁会”"><span class="nav-text">Sentinel的“仲裁会”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置版本号"><span class="nav-text">配置版本号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置传播"><span class="nav-text">配置传播</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDOWN和ODOWN的更多细节"><span class="nav-text">SDOWN和ODOWN的更多细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sentinel之间和Slaves之间的自动发现机制"><span class="nav-text">Sentinel之间和Slaves之间的自动发现机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络隔离时的一致性"><span class="nav-text">网络隔离时的一致性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sentinel状态持久化"><span class="nav-text">Sentinel状态持久化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无failover时的配置纠正"><span class="nav-text">无failover时的配置纠正</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slave选举与优先级"><span class="nav-text">Slave选举与优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sentinel和Redis身份验证"><span class="nav-text">Sentinel和Redis身份验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sentinel-API"><span class="nav-text">Sentinel API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel命令"><span class="nav-text">Sentinel命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态修改Sentinel配置"><span class="nav-text">动态修改Sentinel配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增加或删除Sentinel"><span class="nav-text">增加或删除Sentinel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除旧master或者不可达slave"><span class="nav-text">删除旧master或者不可达slave</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发布-订阅"><span class="nav-text">发布/订阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TILT-模式"><span class="nav-text">TILT 模式</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jianzhao Chen</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://chenjianzhao.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2017/07/18/Redis/sentinel/';
          this.page.identifier = '2017/07/18/Redis/sentinel/';
          this.page.title = 'Redis 之 Sentinel';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://chenjianzhao.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  





  






  





  

  

  

  

</body>
</html>
